# ПОДРОБНЫЕ ПОЯСНЕНИЯ К ДОМАШНИМ ЗАДАНИЯМ:
#----------------------------------------------------------------------------------------------------------------------#
                                                    # Module 3
                                        # DZ lesson 1. Задача "Счётчик вызовов"
                        # Цель: применить на практике начальные знания о пространстве имён и оператор
                                        # global. Закрепить навыки из предыдущих модулей.
#----------------------------------------------------------------------------------------------------------------------#
    # Глобальная переменная для подсчёта вызовов
calls = 0
    # В начале программы создается переменная calls и присваивается значение 0. Она будет использоваться для подсчета
    # общего числа вызовов функций, в которых применяется подсчет
#----------------------------------------------------------------------------------------------------------------------#
                                        # Функция для подсчёта вызовов
def count_calls():
    global calls                                                # Указываем, что используем глобальную переменную
    calls += 1                                                  # Увеличиваем счётчик на 1 с каждым вызовом ф-ии
# 1. Функция count_calls()
    # Эта функция выполняет всего одну задачу — увеличивает на 1 глобальную переменную calls каждый раз, когда она
    # вызывается. Обратите внимание, что для работы с глобальной переменной используется ключевое слово global.
    # Оно говорит Python, что переменная calls — это не локальная переменная внутри функции, а глобальная,
    # которая была определена вне функции.Когда count_calls() вызывается в других функциях,
    # глобальная переменная calls увеличивается на 1, тем самым отслеживается, сколько раз были вызваны функции,
    # в которых используется этот подсчет.
#----------------------------------------------------------------------------------------------------------------------#
                                        # Функция для работы со строкой
def string_info(string):
    count_calls()                                               # вызываем в ф-ии ф-ию count_calls
    length = len(string)                                        # Подсчитываем длину строки
    upper_case = string.upper()                                 # Переводим в верхний регистр
    lower_case = string.lower()                                 # Переводим в нижний регистр
    return length, upper_case, lower_case                       # Возвращаем длину и строку в верхнем, нижнем регистрах
# 2. Функция string_info(string)
    # Функция string_info(string) принимает строку string в качестве аргумента и выполняет следующие шаги:
    #   1. Вызов count_calls():
    # Каждый раз, когда вызывается string_info, она вызывает функцию count_calls, увеличивая счетчик calls на 1.
    # Это отслеживает, сколько раз была вызвана эта функция.
    #   2. Подсчет длины строки: Используется встроенная функция len(string), которая возвращает количество символов в
    # строке. Этот результат сохраняется в переменную length.
    #   3. Преобразование строки в верхний регистр: Используем метод upper() для строки, который возвращает новую строку,
    # где все символы приведены к верхнему регистру. Результат сохраняется в переменную upper_case.
    #   4. Преобразование строки в нижний регистр: Аналогично предыдущему шагу, используем метод lower(),
    # который преобразует строку в нижний регистр, и сохраняем результат в переменную lower_case.
    #   5. Возвращаем результат: Функция возвращает кортеж с тремя значениями: длина строки, строка в верхнем регистре,
    # строка в нижнем регистре.
#----------------------------------------------------------------------------------------------------------------------#
                                        # Функция для проверки наличия строки в списке
def is_contains(string, list_to_search):
    count_calls()                                               # Вызываем в ф-ии ф-ию count_calls
    string_lower = string.lower()                               # Приводим строку к нижнему регистру
    # Перебор элементов списка и сравнение с искомой строкой
    for i in list_to_search:                                    # Перебираем список
        if string_lower == i.lower():                           # Приводим список к нижнему регистру
            return True
    return False
# 3. Функция is_contains(string, list_to_search) Функция is_contains принимает два аргумента:
    # string — строка, которую мы ищем в списке.
    # list_to_search — список строк, в котором мы ищем указанную строку.
    # Далее :
    #   1.Вызов count_calls():Каждый раз, когда вызывается is_contains, она вызывает функцию count_calls,
    #   увеличивая счетчик calls на 1.
    #   2. Приведение строки к нижнему регистру:Вначале строку string приводим к нижнему регистру с помощью метода
    #   lower(). Это нужно для того, чтобы поисковый запрос был нечувствителен к регистру.
    #   3. Перебор элементов списка: Мы начинаем перебирать каждый элемент списка list_to_search с помощью цикла
    #   for i in list_to_search.
    #   4. Сравнение строк: Для каждого элемента списка также приводим его к нижнему регистру с помощью метода lower()
    #   и сравниваем его с искомой строкой. Если элемент из списка совпадает с искомой строкой,
    #   то функция сразу возвращает True.
    #   5. Возвращение результата: Если ни один элемент из списка не совпал с искомой строкой, функция возвращает False.
#----------------------------------------------------------------------------------------------------------------------#
    # Вызовы функций с произвольными данными
print(string_info("HelloWorld"))                                # Пример вызова первой функции
print(string_info("Python"))                                    # Ещё один вызов первой функции
    # Без заданного списка ниже, cities, можно указать любой список во 2 значении функции is_contains
cities = ["New York", "Los Angeles", "ChiCago", "Houston"]
print(is_contains("chicago", cities))                     # Пример вызова второй функции
print(is_contains("Miami", cities))                       # Ещё один вызов второй функции
    # Вывод общего количества вызовов функций, вызовом переменной в которую сохранялось значение
print("Количество вызовов функций:", calls)
    #После выполнения всех вызовов, программа выводит общее количество вызовов функций, которое хранится в переменной
    # calls. В данном случае, после всех вызовов string_info и is_contains, переменная calls будет содержать значение,
    # равное количеству этих вызовов.
#----------------------------------------------------------------------------------------------------------------------#
    #                                           ИТОГ:
    # 1. Функция count_calls() отслеживает количество вызовов других функций.
    # 2. Функция string_info анализирует строку (подсчитывает длину и переводит её в верхний и нижний регистры).
    # 3. Функция is_contains проверяет, содержится ли строка в списке (сравнивая без учета регистра).
    # 4. В конце выводится общее количество вызовов функций.
#----------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------------------------------------------------------------------------#
                                                    # Module 3
                                        # DZ lesson 2 Задача "Рассылка писем":
                        # Цель: закрепить знания о параметрах по умолчанию и именованных аргументах.
#----------------------------------------------------------------------------------------------------------------------#
def send_email(message, recipient, *, sender="university.help@gmail.com"):
    # 1. Объявление функции:
    # message: Содержимое письма.
    # recipient: Адрес электронной почты получателя.
    # sender: Адрес электронной почты отправителя. По умолчанию это "university.help@gmail.com".
    # *: Обозначает, что все аргументы после * должны передаваться только как именованные аргументы.
#----------------------------------------------------------------------------------------------------------------------#
                                        # 2. Проверка корректности адресов:
    if '@' not in sender or '@' not in recipient or not recipient.endswith(('.com', '.ru', '.net')):
        print(f'Невозможно отправить письмо с адреса {sender} на адрес {recipient}')
        return
    # 2. Проверка корректности адресов:
    # Проверяется, содержит ли адрес отправителя(sender) и получателя(recipient) символ '@'.
    # Убедитесь, что адрес получателя заканчивается на.com,.ru или.net.
    # Если любое из условий не выполняется, функция выводит сообщение об ошибке и прекращает выполнение с помощью return
#----------------------------------------------------------------------------------------------------------------------#
                                        # 3. Проверка на отправку самому себе:
    if sender == recipient:
        print('Невозможно отправить письмо самому себе!')
        return
    # 3. Проверка на отправку самому себе:
    # Если адрес отправителя совпадает с адресом получателя, функция выводит сообщение и завершает выполнение.
#----------------------------------------------------------------------------------------------------------------------#
                                        # 4. Логика для стандартного и нестандартного отправителя:
    if sender == 'university.help@gmail.com':
        print(f'Письмо успешно отправлено с адреса {sender} на адрес {recipient}.')
    else:
        print(f'HЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса {sender} на адрес {recipient}.')
    # 4. Логика для стандартного и нестандартного отправителя:
    # Если отправитель — стандартный (по умолчанию "university.help@gmail.com"), выводится сообщение об успешной отправке.
    # Если отправитель отличается от стандартного, функция сообщает, что использован нестандартный отправитель.
#----------------------------------------------------------------------------------------------------------------------#
    #5. Примеры вызова функции
send_email('Hello', 'wishiviaster99@gmail.com')
send_email('Hello', 'recipient@example.com', sender='university.heelp@gmail.com')
send_email('Hello', 'wishiviaster99gmail.com')
send_email('Hello', 'university.help@gmail.com')
#----------------------------------------------------------------------------------------------------------------------#
                                                    # ИТОГ
# Функция выполняет проверки корректности входных данных и выводит действия в консоль. Она не отправляет реальные письма,
# а лишь имитирует этот процесс с помощью сообщений.
#----------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------------------------------------------------------------------------#
                                                    # Module 3
                                        # DZ lesson 3 Задача "Распаковка":
                    # Цель задания: Освоить создание функций с параметрами по умолчанию и практику вызова
                                    # этих функций с различным количеством аргументов.
#----------------------------------------------------------------------------------------------------------------------#
                                        # Функция с параметрами по умолчанию:
def print_params(a = 1, b = 'строка', c = True):
    print(a, b, c)
    # 1. Объявление функции:
    # a: Параметр со значением по умолчанию 1 (число).
    # b: Параметр со значением по умолчанию 'строка' (строка).
    # c: Параметр со значением по умолчанию True (логическое значение).
    # Внутри функции происходит вывод значений параметров на экран с помощью print.
    # Вызов функции с новыми аргументами для замены параметров по умолчанию
#----------------------------------------------------------------------------------------------------------------------#
print('Вызов ф-ии с присвоенными параметрами по умолчанию, при создании ф-ии:                           ', end='')
print_params()
    # 2. Вызов функции без аргументов:
    # Используются значения по умолчанию: 1, 'строка', True.
    # Вывод: 1 строка True.
#----------------------------------------------------------------------------------------------------------------------#
print('Вызов ф-ии с передачей аргумента для имени а, другого значения:                                  ', end='')
print_params(10)
    # 3. Вызов функции с одним позиционным аргументом:
    # a принимает значение 10, остальные параметры остаются по умолчанию ('строка' и True).
    # Вывод: 10 строка True.
#----------------------------------------------------------------------------------------------------------------------#
print('Вызов ф-ии с передачей аргумента для имени b, с переназначением как именованное:                 ', end='')
print_params(b = 25)
    # 4. Вызов функции с одним именованным аргументом:
    # Параметр b устанавливается в 25.
    # Параметры a и c используют значения по умолчанию (1 и True).
    # Вывод: 1 25 True.
#----------------------------------------------------------------------------------------------------------------------#
print('Вызов ф-ии с передачей аргумента для имени с, с переназначением как именованное:                 ', end='')
print_params(c = [1, 2, 3])
    # 5. Вызов функции с изменённым параметром c:
    # Параметр c получает список [1, 2, 3].
    # Остальные параметры (a и b) используют значения по умолчанию.
    # Вывод: 1 строка [1, 2, 3].
#----------------------------------------------------------------------------------------------------------------------#
    # Создан список и словарь:
list_ = [3, 'Hi', 3.14]
dict_ = {'a': [3, 2, 1], 'b': {5, 6.6, 'hello'}, 'c': True}
#----------------------------------------------------------------------------------------------------------------------#
print('Вызов ф-ии с распаковкой аргументов из списка list_ для имён  a, b, c:                           ', end='')
print_params(*list_)
    # 6. Распаковка списка как аргументов функции:
    # Оператор * распаковывает список list_ и передаёт его элементы в качестве отдельных аргументов функции.
    # a получает значение 3, b — 'Hi', c — 3.14.
    # Вывод: 3 Hi 3.14.
#----------------------------------------------------------------------------------------------------------------------#
print('Вызов ф-ии с распаковкой аргументов из словаря dict_ для имён a, b, c:                           ', end='')
print_params(**dict_)
    # 7. Распаковка словаря как именованных аргументов
    # Оператор ** распаковывает словарь и передаёт его ключи-значения как именованные аргументы функции.
    # a получает список [3, 2, 1].
    # b получает множество {5, 6.6, 'hello'}.
    # c получает True.
    # Вывод: [3, 2, 1] {5, 6.6, 'hello'} True.
#----------------------------------------------------------------------------------------------------------------------#
    # Распаковка списка + отдельный аргумент a для замены параметров по умолчанию:
values_list2 = [54.32, 'Строка']
print('Вызов ф-ии c передачей аргументов из списка для имён a, b и отдельным аргументом  для имени c:   ', end='')
print_params(*values_list2, 42)
    # 8. Распаковка списка и передача дополнительного аргумента:
    # Оператор * распаковывает список values_list2: 54.32 передаётся как a, 'Строка' — как b.
    # Дополнительное значение 42 передаётся как c.
    # Вывод: 54.32 Строка 42.
#----------------------------------------------------------------------------------------------------------------------#
                                                    # ИТОГ:
# Этот код демонстрирует:
# Аргументы по умолчанию: позволяют вызвать функцию без указания всех параметров.
# Именованные аргументы: позволяют задавать параметры в любом порядке.
# Распаковка коллекций: позволяет передавать элементы списков или словарей как отдельные аргументы функции.
# Функция print_params универсальна и гибка благодаря такому подходу.
#----------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------------------------------------------------------------------------#
                                                    # Module 3
                                        # DZ lesson 4 Задача "Однокоренные":
                    #Цель: закрепить знание использования параметров *args/ **kwargs на практике.
#----------------------------------------------------------------------------------------------------------------------#
def single_root_words(root_word,*other_words):
    # 1. Объявление функции:
    # root_word: Обязательный аргумент, представляющий корневое слово, с которым будут сравниваться остальные слова.
    # *other_words: Позиционный параметр с * (звездочкой) означает, что функция принимает переменное количество
    # дополнительных аргументов. Они собираются в кортеж other_words.
#----------------------------------------------------------------------------------------------------------------------#
    # Пустой список для подходящих слов
    same_words = []
    # 2. Создание пустого списка:
    # Создается пустой список same_words, куда будут добавляться слова из *other_words, которые подходят по условию.
#----------------------------------------------------------------------------------------------------------------------#
    # Перебираем все слова из *other_words
    for i in other_words:
    # 3. Цикл для перебора слов:
    # Цикл проходит по каждому слову в кортежe other_words. На каждой итерации переменная i представляет
    # очередное слово из этого кортежа.
#----------------------------------------------------------------------------------------------------------------------#
    # Проверяем root_word и *other_word на похожие слова
        if root_word.lower() in i.lower() or i.lower() in root_word.lower():
    # 4. Проверка условия на соответствие:
    # Оба слова приводятся к нижнему регистру с помощью метода .lower(). Это делает сравнение нечувствительным
    # к регистру (например, Hello и hello будут считаться одинаковыми).
    # Проверяется два условия:
    # root_word.lower() in i.lower(): Проверяет, содержится ли корневое слово в текущем слове из списка.
    # i.lower() in root_word.lower(): Проверяет, содержится ли текущее слово из списка в корневом слове.
    # Если хотя бы одно из условий истинно, слово i добавляется в список same_words.
#----------------------------------------------------------------------------------------------------------------------#
            same_words.append(i)
    # 5. Добавление подходящих слов в список:
    # Если слово прошло проверку, оно добавляется в список same_words.
#----------------------------------------------------------------------------------------------------------------------#
    return same_words
    # 6. Возвращение итогового списка:
    # Функция возвращает список same_words, содержащий слова, которые соответствуют условиям.
#----------------------------------------------------------------------------------------------------------------------#
print(single_root_words('Hello','hello','llo','asd','home','HELLO',''))
print(single_root_words('Elephant','Sas','Phanta','phantomas','ever','ant','elephan'))
    # 7. Вызовы функции и разбор результатов
#----------------------------------------------------------------------------------------------------------------------#
                                                # Итог:
# Функция single_root_words находит слова из переданных аргументов, которые содержат корневое слово или являются частью
# этого слова. Она эффективно использует цикл и строковые методы для обработки и фильтрации данных
#----------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------------------------------------------------------------------------#
                                                    # Module 3
                                    # DZ lesson 5 Задача "Рекурсивное умножение цифр":
                                   # Цель: применить знания о рекурсии в решении задачи.
#----------------------------------------------------------------------------------------------------------------------#
    # Определение функции
def get_multiplied_digits(number):
    # 1. Объявление функции:
    # Создается функция get_multiplied_digits, которая принимает один аргумент (number). Этот аргумент должен быть
    # целым числом.
#----------------------------------------------------------------------------------------------------------------------#
    str_number=str(number)                                              # Преобразуем число в строку
    # 2. Преобразование числа в строку:
    # Число number преобразуется в строку и сохраняется в переменной str_number. Это позволяет обрабатывать
    # каждую цифру числа по отдельности.
    # Например: 44444 → '44444'
#----------------------------------------------------------------------------------------------------------------------#
    if len(str_number) > 1:                                             # Если длина строки больше 1, выполняем рекурсию
    # 3. Проверка длины строки:
    # Проверяется, состоит ли строка из более чем одной цифры:
    #     Если да → выполняется рекурсивный вызов.
    #     Если нет (т.е., строка состоит из одной цифры) → обрабатывается базовый случай рекурсии.
#----------------------------------------------------------------------------------------------------------------------#
        first=int(str_number[0])                                        # Первая цифра
    # 4. Извлечение первой цифры:
    # Переменная first получает значение первой цифры числа (строки), преобразованной обратно в целое число.
    # Например: '44444' → первая цифра '4' → first = 4
#----------------------------------------------------------------------------------------------------------------------#
        return first * get_multiplied_digits(int(str_number[1:]))       # Возвращаем Рекурсивный вызов для оставшейся
    # 5. Рекурсивный вызов:                                                                               части числа
    # Возвращается результат умножения первой цифры на результат рекурсивного вызова функции для оставшейся части строки.
    # str_number[1:] берёт всё, кроме первой цифры (срез строки).
    # Например: Для числа '44444':
    #           Первая цифра: 4
    #           Оставшиеся цифры: '4444'
    #           Рекурсивный вызов: 4 * get_multiplied_digits(4444)
#----------------------------------------------------------------------------------------------------------------------#
    else:
        return int(str_number[0])                                       # Иначе если длина строки 1,возвращаем саму цифру
    # 6. Базовый случай рекурсии:
    # Если строка состоит из одной цифры (базовый случай рекурсии), функция просто возвращает эту цифру как целое число.
    # Например: Если str_number — '4', то возвращается 4.
#----------------------------------------------------------------------------------------------------------------------#
    # Определение глобальных переменных с передачей данных аргументов в number
result_1=get_multiplied_digits(44444)
result_2=get_multiplied_digits(5555)
    # 7. Вызов функции и сохранение результата:
    # Вызов функции с разными значениями:
#     get_multiplied_digits(44444):
#         Вычисляется: 4×4×4×4×4=10244×4×4×4×4=1024
#     get_multiplied_digits(5555):
#         Вычисляется: 5×5×5×5=6255×5×5×5=625
#----------------------------------------------------------------------------------------------------------------------#
    # Вывод результата
print(result_1)
print(result_2)
#----------------------------------------------------------------------------------------------------------------------#
                                                    # Итог:
#Этот код демонстрирует применение рекурсии для перемножения всех цифр числа. Рекурсивные вызовы продолжаются до тех пор,
#пока не останется одна цифра, после чего начинается обратное умножение.
#----------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------------------------------------------------------------------------#
#----------------------------------------------------------------------------------------------------------------------#